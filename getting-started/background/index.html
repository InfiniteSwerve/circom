<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="canonical" href="http://127.0.0.1:8000/getting-started/background/">
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Background on ZK - Circom 2 Documentation</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../../css/theme.css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Background on ZK";
    var mkdocs_page_input_path = "getting-started/background.md";
    var mkdocs_page_url = "/getting-started/background/";
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> Circom 2 Documentation</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <p class="caption"><span class="caption-text">Getting started</span></p>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Background on ZK</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#zero-knowledge-proofs">Zero-knowledge proofs </a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#arithmetic-circuits">Arithmetic circuits </a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#signals-of-a-circuit">Signals of a circuit </a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_1">â€‹ </a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#rank-1-constraint-system">Rank-1 constraint system </a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#witness">Witness </a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#summary">Summary </a>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../installation/">Installation</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../writing-compiling-circuits/">Writing and compiling circuits</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../computing-the-witness/">Computing the witness</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../proving-circuits/">Proving circuits with ZK</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">The circom Language</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="#">Signals</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../circom-language/signals/">Signals</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../circom-language/variables-and-mutability/">Variables & Mutability</a>
                </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="#">Templates</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../circom-language/templates-and-components/">Templates & Components</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../circom-language/pragma/">Pragma</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../circom-language/functions/">Functions</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../circom-language/include/">Include</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../circom-language/the-main-component/">The main Component</a>
                </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="#">Syntax</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../circom-language/comment-lines/">Comment Lines</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../circom-language/identifiers/">Identifiers</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../circom-language/reserved-keywords/">Reserved-keywords</a>
                </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../circom-language/basic-operators/">Basic Operators</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../circom-language/constraint-generation/">Constraint Generation</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../circom-language/control-flow/">Control Flow</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../circom-language/data-types/">Data Types</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../circom-language/scoping/">Scoping</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="#">Code Quality</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../circom-language/code-quality/code-assertion/">Code Assertion</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../circom-language/code-quality/debugging-operations/">Debugging Operations</a>
                </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="#">Circom Insight</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../circom-language/circom-insight/circom-phases/">Compiler Phases</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../circom-language/circom-insight/compiler-messages/">Compiler Messages</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../circom-language/circom-insight/unknowns/">Unknowns</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../circom-language/circom-insight/circom-library/">Circom Library</a>
                </li>
    </ul>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">Circom 2 Documentation</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>Getting started &raquo;</li>
        
      
    
    <li>Background on ZK</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>

          <div role="main">
            <div class="section">
              
                <h1 id="background">Background</h1>
<h2 id="zero-knowledge-proofs">Zero-knowledge proofs <a id="zero-knowledge-proofs"></a></h2>
<p>Recently, a set of cryptographic primitives called <strong>zero-knowledge proofs</strong> (ZKPs) agitated the world of public blockchains and distributed ledgers. ZKPs came up first as a <strong>solution to privacy</strong> issues but they have lately also stood up as a perfect <strong>solution to scalability</strong> issues. As a result, these cryptographic proofs have become very attractive tools to the blockchain community, and the most efficient algorithms have already been deployed and integrated in several applications.</p>
<p>A zero-knowledge proof is a protocol that enables one party, called the <strong>prover</strong>, to convince another, the <strong>verifier</strong>, that a statement is true without revealing any information beyond the veracity of the statement. For example, a prover can create proofs for statements like the following:</p>
<ul>
<li><em>"I know the private key that corresponds to this public key"</em> : in this case, the proof would not reveal any information about the private key.</li>
<li><em>"I know a private key that corresponds to a public key from this list"</em> : as before, the proof would not reveal information about the private key but in this case, the associated public key would also remain private.</li>
<li><em>"I know the preimage of this hash value"</em> : in this case, the proof would show that the prover knows the preimage but it would not reveal any information about the value of that preimage.</li>
<li><em>"This is the hash of a blockchain block that does not produce negative balances"</em> : in this case, the proof would not reveal any information about the amount, origin or destination of the transactions included in the block.</li>
</ul>
<p><strong>Non-interactive zero-knowledge proofs</strong> (NIZK) are a particular type of zero-knowledge proofs in which the prover can generate the proof without interaction with the verifier. NIZK protocols are very suitable for Ethereum blockchain applications, because they <strong>allow a smart contract to act as a verifier</strong>. This way, anyone can generate a proof and send it as part of a transaction to the smart contract, which can perform some action depending on whether the proof is valid or not.</p>
<p>In this context, the most preferable NIZK are <strong>zk-SNARK</strong> proofs (Zero-knowledge Succinct Non Interactive ARgument of Knowledge), a set of non-interactive zero-knowledge protocols that have <strong>succinct proof size</strong> and <strong>sublinear verification time</strong>. The importance of these protocols is double: on the one hand, they help improve privacy guarantees, but on the other, their small proof size has been used in scalability solutions.</p>
<h2 id="arithmetic-circuits">Arithmetic circuits <a id="arithmetic-circuits"></a></h2>
<p>Like most ZKPs, zk-SNARKs permit proving <strong>computational statements</strong>, but they cannot be applied to the computational problem directly, the statement first needs to be converted into the right form. Specifically, zk-SNARKs requires the computational statement to be modeled with an arithmetic circuit. Although it may not always be obvious how to do this conversion, most computational problems we care about can easily be converted into arithmetic circuits.</p>
<p>An <strong><code>F_p</code>-arithmetic circuit</strong> is a circuit consisting of set of wires that carry values from the field <code>F_p</code> and connect them to addition and multiplication gates <code>modulo p</code>.</p>
<p>ðŸ‘‰ Remember that given a prime number <code>p</code>, the <strong>finite field</strong> <strong><code>F_p</code></strong> consists of the set of numbers <code>{0,...,p-1}</code>on which we can add and multiply these numbers modulo <code>p</code>.</p>
<p>For example, the finite field <code>F_7</code> consists of the set of numbers <code>{0,...,6}</code>on which we can add and multiply numbers modulo <code>7</code>. An easy way to understand how operating modulo <code>7</code> works, is to <strong>think of a clock of 7 hours</strong> in which we do not care about how many times the hands have turned the clock, only what time they mark. In other words, we only care about the reminder of dividing by 7. For instance:</p>
<ul>
<li><code>15 modulo 7 = 1</code>, since <code>15 = 7 + 7 + 1</code></li>
<li><code>7 modulo 7 = 0</code></li>
<li><code>4*3 modulo 7 = 5</code>, since <code>4*3 = 12 = 7 + 5</code></li>
</ul>
<h2 id="signals-of-a-circuit">Signals of a circuit <a id="signals-of-a-circuit"></a></h2>
<p>So, an arithmetic circuit takes some <strong>input signals</strong> that are values between <code>0,...,p-1</code> and performs additions and multiplications between them modulo the prime <code>p</code>. The output of every addition and multiplication gate is considered an <strong>intermediate signal</strong>, except for the last gate of the circuit, the output of which<strong>,</strong> is the <strong>output signal</strong> of the circuit.</p>
<p>To generate and validate zk-SNARK proofs in <strong>Ethereum</strong>, we need to work with <code>F_p</code>-arithmetic circuits, taking the prime:</p>
<pre><code class="language-text">p = 21888242871839275222246405745257275088548364400416034343698204186575808495617
</code></pre>
<p>In the figure below, we have defined an <code>F_7</code>-arithmetic circuit that performs the operation: <code>out = a*b + c</code>. The circuit has 5 signals: the signals <code>a</code>, <code>b</code> and <code>c</code> are input signals, <code>d</code> is an intermediate signal and the<code>out</code> signal is the output of the circuit.</p>
<p><img alt="" src="https://gblobscdn.gitbook.com/assets%2F-MDt-cjMfCLyy351MraT%2F-MHR5icu-Jxuas-UC7DY%2F-MHR60RuAQK6qNzhOPgE%2Foutput.jpg?alt=media&amp;token=39d3d332-cac5-4546-ab43-9f489241ae50" /></p>
<h3 id="_1">â€‹ <a id="undefined"></a></h3>
<p>In order to use zk-SNARK protocols, we need to describe the relation between signals as a system of equations that relate variables with gates. From now on, the equations that describe the circuit will be called <strong>constraints</strong>, and you can think of them as conditions that signals of that circuit must satisfy.</p>
<h2 id="rank-1-constraint-system">Rank-1 constraint system <a id="rank-1-constraint-system"></a></h2>
<p>If we have an arithmetic circuit with signals <code>s_1,...,s_n</code>, then we define a <strong>constraint</strong> as an equation of the following form:</p>
<p><code>(a_1*s_1 + ... + a_n*s_n) * (b_1*s_1 + ... + b_n*s_n) + (c_1*s_1 + ... + c_n*s_n) = 0</code></p>
<p>Note that constraint <strong>must be quadratic, linear or constant equations</strong>, and sometimes, by doing small modifications (like a change of variable or gathering two constraints), it is possible to reduce the number of constraints or variables. In general, circuits will have several constraints (typically, one per multiplicative gate). The set of constraints describing the circuit is called <strong>rank-1 constraint system</strong> (R1CS):</p>
<p><code>(a_11*s_1 + ... + a_1n*s_n)*(b_11*s_1 + ... + b_1n*s_n) + (c_11*s_1 + ... + c_1n*s_n) = 0 (a_21*s_1 + ... + a_2n*s_n)*(b_21*s_1 + ... + b_2n*s_n) + (c_21*s_1 + ... + c_1n*s_n) = 0 (a_31*s_1 + ... + a_3n*s_n)*(b_31*s_1 + ... + b_3n*s_n) + (c_31*s_1 + ... + c_1n*s_n) = 0 ... (a_n1*s_1 + ... + a_nm*s_n)*(b_n1*s_1 + ... + b_nm*s_n) + (c_n1*s_1 + ... + c_nm*s_n) = 0</code></p>
<p>Remember that operations inside the circuit are performed modulo a certain prime <code>p</code>. So, all equations above are defined <code>modulo p</code>.</p>
<p>In the previous example, the R1CS of our circuit consists of the following two equations:</p>
<ul>
<li><code>d = a*b modulo 7</code></li>
<li><code>out = d+c modulo 7</code></li>
</ul>
<p>In this case, by replacing directly the variable <code>d</code>, we can gather the two equations into a single one:</p>
<ul>
<li><code>out = a*b + c modulo 7</code></li>
</ul>
<p>The nice thing about circuits, is that although most <strong>zero-knowledge protocols have an inherent complexity</strong> that can be overwhelming for many developers, the <strong>design of arithmetic circuits is clear and neat</strong>.</p>
<p>ðŸ‘‰ With <code>circom</code>, you design your own circuits with your own constraints, and the compiler outputs the R1CS representation that you will need for your zero-knowledge proof.</p>
<p>Zero-knowledge permits proving <strong>circuit satisfiability</strong>. What this means is, that you can prove that you know a set of signals that satisfy the circuit, or in other words, that you know a solution to the R1CS. This set of signals is called <strong>witness</strong>.</p>
<h2 id="witness">Witness <a id="witness"></a></h2>
<p>Given a set of inputs, the calculation of the intermediate and output signals is pretty straightforward. So, given any set of inputs, we can always calculate the rest of signals. So, why should we talk about circuit satisfiability? The key aspect of zero-knowledge proofs, is that it allows you to compute these circuits without revealing information about the signals.</p>
<p>For instance, imagine that in the previous circuit, the input <code>a</code> is a private key and the input <code>b</code> is the corresponding public key. You may be okay with revealing <code>b</code> but you certainly do not want to reveal <code>a</code>. If we define <code>a</code> as a private input, <code>b</code>, <code>c</code> as public inputs and <code>out</code> as a public output, with zero-knowledge we are able to prove, without revealing its value, that we know a private input <code>a</code> such that, for certain public values <code>b</code>, <code>c</code> and <code>out</code>, the equation <code>a*b + c = out mod 7</code> holds.</p>
<blockquote>
<p>Note that we could easily deduce the value of <code>a</code> by isolating it from the other signals. It is important to design circuits that keep the privacy of the private inputs and prevent deducing them from the R1CS.</p>
</blockquote>
<p>An assignment of the signals is called a <strong>witness</strong>. For example, <code>{a = 2, b = 6, c = -1, out = 4}</code> would be a valid witness for the circuit. The assignment <code>{a = 1, b = 2, c = 1, out = 0}</code> would not be a valid witness, since it does not satisfy the equation <code>a*b - c = out</code>.</p>
<h2 id="summary">Summary <a id="summary"></a></h2>
<p>â€‹<strong>In summary, zk-SNARK proofs are an specific type of zero-knowledge proofs that allow you to prove that you know a a set of signals (witness) that match all the constraints of a circuit without revealing any of the signals except the public inputs and the outputs.</strong></p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../installation/" class="btn btn-neutral float-right" title="Installation">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
      <span><a href="../installation/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
