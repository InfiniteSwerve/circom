<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="canonical" href="http://127.0.0.1:8000/getting-started/writing-compiling-circuits/">
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Writing and compiling circuits - Circom 2 Documentation</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../../css/theme.css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Writing and compiling circuits";
    var mkdocs_page_input_path = "getting-started/writing-compiling-circuits.md";
    var mkdocs_page_url = "/getting-started/writing-compiling-circuits/";
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> Circom 2 Documentation</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <p class="caption"><span class="caption-text">Getting started</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="../background/">Background on ZK</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../installation/">Installation</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Writing and compiling circuits</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#writing-our-first-circuit">Writing our first circuit</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#compiling-the-circuit">Compiling the circuit</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#extending-our-multiplier-to-three-inputs">Extending our multiplier to three inputs</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#extending-our-multiplier-to-n-inputs">Extending our multiplier to N inputs</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#writing-a-circuit-for-binary-checks">Writing a circuit for binary checks</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#writing-a-logic-gate-and-with-two-inputs">Writing a logic gate AND with two inputs</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#extending-our-and-logic-gate-to-n-inputs">Extending our AND logic gate to N inputs</a>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../computing-the-witness/">Computing the witness</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../proving-circuits/">Proving circuits with ZK</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">The circom Language</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="#">Signals</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../circom-language/signals/">Signals</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../circom-language/variables-and-mutability/">Variables & Mutability</a>
                </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="#">Templates</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../circom-language/templates-and-components/">Templates & Components</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../circom-language/pragma/">Pragma</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../circom-language/functions/">Functions</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../circom-language/include/">Include</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../circom-language/the-main-component/">The main Component</a>
                </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="#">Syntax</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../circom-language/comment-lines/">Comment Lines</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../circom-language/identifiers/">Identifiers</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../circom-language/reserved-keywords/">Reserved-keywords</a>
                </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../circom-language/basic-operators/">Basic Operators</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../circom-language/constraint-generation/">Constraint Generation</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../circom-language/control-flow/">Control Flow</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../circom-language/data-types/">Data Types</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../circom-language/scoping/">Scoping</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="#">Code Quality</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../circom-language/code-quality/code-assertion/">Code Assertion</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../circom-language/code-quality/debugging-operations/">Debugging Operations</a>
                </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="#">Circom Insight</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../circom-language/circom-insight/circom-phases/">Compiler Phases</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../circom-language/circom-insight/compiler-messages/">Compiler Messages</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../circom-language/circom-insight/unknowns/">Unknowns</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../circom-language/circom-insight/circom-library/">Circom Library</a>
                </li>
    </ul>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">Circom 2 Documentation</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>Getting started &raquo;</li>
        
      
    
    <li>Writing and compiling circuits</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>

          <div role="main">
            <div class="section">
              
                <h1 id="writing-and-compiling-circuits">Writing and compiling circuits</h1>
<p><code>circom</code> allows programmers to define the <a href="/circom-language/constraint-generation">constraints</a> that define the arithmetic circuit. All constraints must be of the form A*B + C = 0, where A, B and C are linear combinations of signals. More details about these equations can be found <a href="/circom-language/constraint-generation">here</a>. </p>
<h2 id="writing-our-first-circuit">Writing our first circuit</h2>
<p>The arithmetic circuits built using <code>circom</code> operate on signals. Let us define our first circuit that simply multiplies two input signals and produces an output signal.</p>
<pre><code class="language-text">pragma circom 2.0.0;

/*This circuit multiplies in1 and in2.*/  

template Multiplier2 () {  

   // Declaration of signals.  
   signal input in1;  
   signal input in2;  
   signal output out;  

   // Statements.  
   out &lt;== in1 * in2;  
}

component main = Multiplier2();
</code></pre>
<p>First, the <code>pragma</code> instruction is used to specify the compiler version. This is to ensure that the circuit is compatible with the compiler version indicated after the <code>pragma</code> instruction. Otherwise, the compiler will throw a warning. </p>
<p>Then, we use the reserved keyword <code>template</code>to define our new circuit, called <code>Multiplier2</code>.  Now, we have to define its <a href="/circom-language/signals">signals</a>. Signals can be named with an identifier, e.g.,  <code>in1, in2, out.</code>  In this circuit, we have two input signals<code>in1, in2</code> and an output signal <code>out</code>.  Finally, we use <code>&lt;==</code> to set that the value of <code>out</code> is the result of multiplying the values of <code>in1</code> and <code>in2</code>.  Equivalently, we could have also used the operator <code>==&gt;</code>, e.g., <code>in1 * in2 ==&gt; out</code>.</p>
<p>Let us notice that in each circuit, we first declare its signals, and after that, the assignments to set the value of the output signals.</p>
<h2 id="compiling-the-circuit">Compiling the circuit</h2>
<p>Once you have the compiler installed you can see the available options as follows:</p>
<pre><code class="language-console">circom --help

   Circom Compiler 2.0
   IDEN3
   Compiler for the Circom programming language

   USAGE:
      circom [FLAGS] [OPTIONS] [input]

   FLAGS:
      -h, --help       Prints help information
         --inspect    Does an additional check over the constraints produced
         --O0         No simplification is applied
      -c, --c          Compiles the circuit to c
         --json       outputs the constraints in json format
         --r1cs       outputs the constraints in r1cs format
         --sym        outputs witness in sym format
         --wasm       Compiles the circuit to wasm
         --wat        Compiles the circuit to wat
         --O1         Only applies var to var and var to constant simplification
      -V, --version    Prints version information

   OPTIONS:
         --O2 &lt;full_simplification&gt;    Full constraint simplification [default: full]
      -o, --output &lt;output&gt;             Path to the directory where the output will be written [default: .]

   ARGS:
      &lt;input&gt;    Path to a circuit with a main component [default: ./circuit.circom]
</code></pre>
<p>We created a template called <code>Multiplier2</code> in <a href="/getting-started/writing-compiling-circuits">Writing our first circuit</a>. 
However, to actually create a circuit, we have to create an instance of this template. To do so, create a file with the following content:</p>
<pre><code class="language-text">pragma circom 2.0.0;

template Multiplier2() {
    signal input a;
    signal input b;
    signal output c;
    c &lt;== a*b;
 }

 component main = Multiplier2();
</code></pre>
<p>After we write our arithmetic circuit using <code>circom</code>, we should save it in a file with the <code>.circom</code> extension. Remember that you can create your own circuits or use the templates from our library of circuits <a href="https://github.com/iden3/circomlib"><code>circomlib</code></a>.</p>
<p>In our example, we create a file called <em>multiplier2.circom</em>.
Now is time to compile the circuit to get a system of arithmetic equations representing it. As a result of the compilation we will also obtain programs to compute the witness.
We can compile the circuit with the following command:</p>
<pre><code class="language-text">circom multiplier2.circom --r1cs --wasm --sym --c
</code></pre>
<p>With these options we generate three types of files:</p>
<ul>
<li><code>--r1cs</code>: it generates the file <code>multiplier2.r1cs</code> that contains the <a href="/getting-started/background#rank-1-constraint-system">R1CS constraint system</a> of the circuit in binary format.</li>
<li><code>--wasm</code>: it generates the directory <code>multiplier2_js</code> that contains the <code>Wasm</code> code (multiplier2.wasm) and other files needed to generate the <a href="/getting-started/background#witness">witness</a>.</li>
<li><code>--sym</code> : it generates the file <code>multiplier2.sym</code> , a symbols file required for debugging or for printing the constraint system in an annotated mode.</li>
<li><code>--c</code> : it generates the directory <code>multiplier2_cpp</code> that contains several files (multiplier2.cpp, multiplier2.dat, and other common files for every compiled program  like main.cpp, MakeFile, etc)  needed to compile the C code to generate the witness.</li>
</ul>
<p>We can use the option -o to specify the directory where these files are created. </p>
<h2 id="extending-our-multiplier-to-three-inputs">Extending our multiplier to three inputs</h2>
<p>Building on top of the 2-input multiplier, we can build a 3-input multiplier.</p>
<pre><code class="language-text">pragma circom 2.0.0;

template Multiplier2(){
     /*Code from the previous example.*/
}

//This circuit multiplies in1, in2, and in3.
template Multiplier3 () {
   //Declaration of signals and components.
   signal input in1;
   signal input in2;
   signal input in3;
   signal output out;
   component mult1 = Multiplier2();
   component mult2 = Multiplier2();

   //Statements.
   mult1.in1 &lt;== in1;
   mult1.in2 &lt;== in2;
   mult2.in1 &lt;== mult1.out;
   mult2.in2 &lt;== in3;
   out &lt;== mult2.out;
}

component main = Multiplier3();
</code></pre>
<p>As expected, we first declare three input signals <code>in1, in2, in3,</code> and an output signal <code>out</code> and two instances of <code>Multiplier2</code> . Instantiations of templates are done using the keyword <code>component</code>. We need an instance <code>mult1</code> to multiply <code>in1</code> and <code>in2</code>. In order to assign the values of the input signals of <code>mult1</code> we use the dot notation <code>"."</code>. Once <code>mult1.in1</code> and <code>mult1.in2</code> have their values set, then the value of <code>mult1.out</code> is computed. This value can be now used to set the input value of <code>mult2</code>  of the second instance of <code>Multiplier2</code>to multiply <code>in1*in2</code> and <code>in3</code> obtaining the final result  <code>in1*in2*in3</code>.</p>
<p>Finally, every execution starts from an initial <a href="/circom-language/the-main-component">main component</a> defined as follows.</p>
<pre><code class="language-text">component main {public [in1,in2,in3]} = Multiplier3();
</code></pre>
<p>Here, we indicate that the initial component for our first circom program is the circuit <code>Multiplier3</code> which has three public signals: <code>in1, in2</code> and <code>in3</code>.
In circom, all output signals of the main component are public (and cannot be made private), the input signals of the main component are private if not stated otherwise using the keyword public as avobe. The rest of signals are all private and cannot be made public.</p>
<h2 id="extending-our-multiplier-to-n-inputs">Extending our multiplier to N inputs</h2>
<p>When defining a template, we can use <a href="/circom-language/templates-and-components">parameters</a> to build generic circuits. These parameters must have a <a href="/circom-language/circom-insight/unknowns">known</a> value at the moment of the instantiation of the template. Following up the previous example, we can implement an N-input multiplier, where <code>N</code> is a parameter.</p>
<pre><code class="language-text">pragma circom 2.0.0; 

template Multiplier2(){
     /*Code from the previous example.*/
}

template MultiplierN (N){
   //Declaration of signals and components.
   signal input in[N];
   signal output out;
   component comp[N-1];

   //Statements.
   for(var i = 0; i &lt; N-1; i++){
       comp[i] = Multiplier2();
   }

   // ... some more code (see below)

}

component main = MultiplierN(4);
</code></pre>
<p>In addition to the parameter<code>N</code>, two well-known concepts appear in this fragment of code: <a href="/circom-language/data-types">arrays</a> and <a href="/circom-language/data-types">integer variables</a>. </p>
<p>As we have seen for a 3-input multiplier, we need 3 input signals and 2 components of <code>Multiplier2</code>. Then, for an N-input multiplier, we need an N-dimensional array of input signals and an (N-1)-dimensional array of components of <code>Multiplier2</code>. </p>
<p>We also need an integer variable <code>i</code> to instantiate each component <code>comp[i]</code>. Once this is done, we have to set the signals for each component as follows:</p>
<pre><code class="language-text">   comp[0].in1 &lt;== in[0];
   comp[0].in2 &lt;== in[1];
   for(var i = 0; i &lt; N-2; i++){
       comp[i+1].in1 &lt;== comp[i].out;
       comp[i+1].in2 &lt;== in[i+2]; 
   }
   out &lt;== comp[N-2].out; 
}
</code></pre>
<p>Similarly to <code>Multiplier3</code>, each output signal of a component becomes one of the input signals of the next component. Finally, <code>out</code> is set as the output signal of the last component and its value will be <code>in[0]*in[1]*...*in[N-1]</code>. Finally, we define as main component a <code>MultiplierN</code> with <code>N = 3</code>.</p>
<pre><code class="language-text">component main {public [in]} = MultiplierN(3);
</code></pre>
<pre><code class="language-text">pragma circom 2.0.0;

template Multiplier2(){
   //Declaration of signals.
   signal input in1;
   signal input in2;
   signal output out;

   //Statements.
   out &lt;== in1 * in2;
}

template Multiplier3 () {
   //Declaration of signals.
   signal input in1;
   signal input in2;
   signal input in3;
   signal output out;
   component mult1 = Multiplier2();
   component mult2 = Multiplier2();

   //Statements.
   mult1.in1 &lt;== in1;
   mult1.in2 &lt;== in2;
   mult2.in1 &lt;== mult1.out;
   mult2.in2 &lt;== in3;
   out &lt;== mult2.out;
}

template MultiplierN (N){
   //Declaration of signals.
   signal input in[N];
   signal output out;
   component comp[N-1];

   //Statements.
   for(var i = 0; i &lt; N-1; i++){
       comp[i] = Multiplier2();
   }
   comp[0].in1 &lt;== in[0];
   comp[0].in2 &lt;== in[1];
   for(var i = 0; i &lt; N-2; i++){
       comp[i+1].in1 &lt;== comp[i].out;
       comp[i+1].in2 &lt;== in[i+2];

   }
   out &lt;== comp[N-2].out; 
}

component main {public [in]} = MultiplierN(3);
</code></pre>
<h2 id="writing-a-circuit-for-binary-checks">Writing a circuit for binary checks</h2>
<p>Let us build a circuit that checks if the input signal is binary. In case it is, the circuit returns an output signal with the same value than<code>in</code>. </p>
<pre><code class="language-text">pragma circom 2.0.0;

template binaryCheck () {

   // Declaration of signals.

   signal input in;
   signal output out;

   // Statements.

   in * (in-1) === 0;
   out &lt;== in;
}

component main = binaryCheck();
</code></pre>
<p>After declaring the signals of the circuit, we use the operator <code>===</code>to introduce the constraint <code>in * (in -1) = 0</code>. The solutions of this constraint are <code>in = 0</code> and <code>in = 1</code>. This means that the constraint has solution if and only if the input signal is binary.</p>
<p>The instruction <code>out &lt;== in</code> not only assigns the value of signal <code>in</code> to signal <code>out</code>, but it also adds the constraint <code>out = in</code> to the set of constraints that define the circuit. Then, when both constraints have solution, it is guaranteed that the output signal is binary. Sometimes, we only want to assign the value of a signal but not adding the corresponding constraint. In this case, we will use the operator <code>&lt;--</code> and <code>--&gt;</code>. The differences between <code>&lt;--/--&gt;</code> and <code>&lt;==/==&gt;</code> are described <a href="/circom-language/signals">here</a>.</p>
<h2 id="writing-a-logic-gate-and-with-two-inputs">Writing a logic gate AND with two inputs</h2>
<p>We are going to use the circuits <code>Multiplier2</code> and <code>binaryCheck</code> to build a 2-gate logic AND.</p>
<pre><code class="language-text">pragma circom 2.0.0;

template Multiplier2(){
   //Declaration of signals
   signal input in1;
   signal input in2;
   signal output out;

   //Statements.
   out &lt;== in1 * in2;
}

template binaryCheck () {
   //Declaration of signals.
   signal input in;
   signal output out;

   //Statements.
   in * (in-1) === 0;
   out &lt;== in;
}

template And2(){
   //Declaration of signals and components.
   signal input in1;
   signal input in2;
   signal output out;
   component mult = Multiplier2();
   component binCheck[2];

   //Statements.
   binCheck[0] = binaryCheck();
   binCheck[0].in &lt;== in1;
   binCheck[1] = binaryCheck();
   binCheck[1].in &lt;== in2;
   mult.in1 &lt;== binCheck[0].out;
   mult.in2 &lt;== binCheck[1].out;
   out &lt;== mult.out;
}

component main = And2();
</code></pre>
<p>Simplifying, the 2-gate AND circuit can be defined by the next constraints:</p>
<p><code>in1 * (in1 - 1) = 0</code>, <code>in2 * (in2 - 1) = 0</code>, <code>out = in1 * in2</code></p>
<p>These constraints are satisfiable if and only  if <code>in1, in2</code> are binary signals. Consequently, <code>out</code> will also be binary.</p>
<h2 id="extending-our-and-logic-gate-to-n-inputs">Extending our AND logic gate to N inputs</h2>
<p>Finally, let us build an N-gate logic AND using circuit <code>Multiplier2</code> and <code>binaryCheck</code>.</p>
<pre><code class="language-text">pragma circom 2.0.0;

template binaryCheck () {
   /*Code from previous example*/
}

template Multiplier2 () {
   /*Code from previous example*/
}

template AndN (N){
   //Declaration of signals and components.
   signal input in[N];
   signal output out;
   component mult[N-1];
   component binCheck[N];

   //Statements.
   for(var i = 0; i &lt; N; i++){
       binCheck[i] = binaryCheck();
         binCheck[i].in &lt;== in[i];
   }
   for(var i = 0; i &lt; N-1; i++){
       mult[i] = Multiplier2();
   }
   mult[0].in1 &lt;== binCheck[0].out;
   mult[0].in2 &lt;== binCheck[1].out;
   for(var i = 0; i &lt; N-2; i++){
       mult[i+1].in1 &lt;== mult[i].out;
       mult[i+1].in2 &lt;== binCheck[i+2].out;

   }
   out &lt;== mult[N-2].out; 
}

component main = AndN(4);
</code></pre>
<p>This program is very similar to <code>MultiplierN</code>, but every  signal involved in it is binary.</p>
<p>It is important to highlight that we cannot use a (2N-1)-dimensional array to instantiate all the components since, every component of an array must be an instance of the same template with (optionally) different parameters.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../computing-the-witness/" class="btn btn-neutral float-right" title="Computing the witness">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../installation/" class="btn btn-neutral" title="Installation"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../installation/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../computing-the-witness/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
